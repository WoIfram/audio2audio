# audio2audio
Скрипт предназначен для автоматического сдвига тайминга субтитров. Т.е. имеется два рипа одного и того же кинца, и субтитры к одному из них. На основе их звукодорожек скрипт должен сопоставить временные метки субтитров моментам второго видео и вернуть четвёртый файл - субтитры ко второму видео, а также вывести информацию о том, в какие местах были произведены сдвиги субтитров: на практике бывают случаи, когда в первом рипе не хватает куска, поэтому это нужно, чтобы можно было просмотреть вручную подозрительные места. Собственно, есть идея вывести ещё и пятый файл - сконструировать из кусков второго видео, отсутствующих в первом, новое видео, которое можно будет просмотреть и проверить, нет ли там новых реплик.
# Формат ввода и вывода
Все данные для запуска скрипта, в частности, путь к медиафайлам и субтитрам, находятся в файле config.py. Надеюсь, по приведённому примеру и комментариям понятно, что каждый из них делает.
# Как это вообще запускать?
Нужен Python 3.5 и библиотеки numpy, scipy. Также я не нашёл более простого способа работы с видео и аудио, кроме как запускать команды FFmpeg из питона, так что FFmpeg тоже должен быть установлен и прописан в PATH. Если вы предпочитаете другой способ конвертации видео в аудио данной частоты, пропишите его вместо <b>call('ffmpeg</b> ... в main.py : эта строчка должна вытаскивать из видео <i>%filename%</i> аудиофайл, сохраняя его в той же директории с названием <i>%wav_file%</i> и частотой <i>%Config.DEFAULT_HZ%</i>.
# Алгоритм
Разобьём аудиодорожки на много мелких кусочков одинаковой длины, эту длину обзовём <b>тиком</b>. Теперь возьмём все куски (накладывающиеся, разумеется) по N подряд стоящих тиков (N=2 в текущей реализации) и подсчитаем спектр для каждого из них. Получим две спектрограммы, которые нужно сопоставить друг другу по похожести. Между любыми двумя спектрами есть некоторое расстояние, подробности см. в коде. Мы хотим, чтобы сопоставлялись куски с как можно меньшим суммарным расстоянием.

Построим граф-решётку, вершинами которого являются пары (спектр номер A из первой спектрограммы, спектр номер B из второй спектрограммы), а рёбра из каждой вершины выходят в трёх направлениях - в (A, B+1) [вертикальное], (A+1, B) [горизонтальное], (A+1, B+1) [диагональное]. Вес диагонального ребра равен расстоянию между спектрами A и B, а горизональных/вертикальных - некоторой константе (1.3 в коде) * среднее расстояние между двумя спектрами (предпосчитывается тысячей рандомных подсчётов расстояний и взятием среднего). Теперь мы ищем кратчайший путь из (0, 0) в противоположный конец прямоугольника. В этом пути диагональным участкам будут соответствовать соответствия в видео, а горизонтальным и вертикальным - вырезанные участки.

А вот в поиске пути начинается магия. Сначала мы берём размер тика довольно большим: например, 2.56 секунды. Теперь проходимся по получившемуся сравнительно небольшому графу алгоритмом A* с тупейшей эвристикой: от вершины до цели не меньше, чем расстояние между их диагоналями по горизонтали. Получаем грубое сопоставление аудиодорожек, которое на практике, тем не менее, должно быть точным с точностью до нескольких секунд, как мне кажется (и простейший эксперимент это подтверждает). Есть некоторые хитрые технические детали реализации A*, чтобы он не потреблял слишком много памяти, но они останутся за кадром, тем более их можно обойти, сделав размер исходного тика достаточно большим.

А дальше начинаем это грубое сопоставление улучшать. Берём тик в 1.28 секунды. У нас уже есть довольно точный маршрут, что ж, строим спектрограммы для нового тика и проходимся обычной динамикой (таким образом, нужно линейное количество памяти - чтобы хранить O(1) вершин последних слоёв и лучшие пути в каждую из них) по всем вершинам, не сильно удалённым от уже имеющегося пути. Т.е. для каждой вершины в уже имеющемся пути (каждое ребро удвоилось, ибо тик в два раза уменьшился), а также для середин диагональных рёбер, мы рассматриваем все вершины вдоль диагонали направления, вдоль которой ребёр нет, удалённых от выбранной точки не больше, чем на некоторое эпсилон. Разрешаем ходить только по ним - получаем очень вытянутый граф размера порядка (эпсилон * длину спектрограммы), в нём динамикой можно обойти вообще все вершины (A * , кажется, работает медленнее, но для однозначного вывода данных недостаточно). После этого мы получаем более точный маршрут. Дальше берём тик в 0.64 секунды и т.д. В конце всё начинает дико тормозить из-за разрастания графа, поэтому на данный момент я останавливаюсь на 0.04 секундах, тем более, что большая точность особо и не нужна.
